Infix | between Type_Exprs must be specially handled. :composition_infix

Interpreter#interp_infix is getting messy. I need to factor out some of the cases. :factor_dot_calls

Improve Praser#precedence_for, get rid of that nested array format.

Clean up Parser#parse_conditional_expr. It should just loop until curr?(end) right? It works as is for now, but it's ugly.

Add more stuff to preload.e. Specifically, a context object that holds useful information about the runtime tree. It should probably hold a lot of information: caller, callee, code location, stack, current scope, etc.

Custom test helpers like assert_operator(out), assert_type(:operator, out). I don't have a preference for either, but it's needed. :lexeme_type_helper.

While loops. Currently it treats while expressions as if expressions. :while_loops

Parsing `Identifier {;}` should raise a syntax error or something, because that's not valid syntax. Currently it loops indefinitely. I know where it happens, I just need to fix it. See :Identifier_function

*_Expr classes have :start_location, :end_location defined, but this is never set. Being able to print relevant code in the output would reduce confusion with errors.

Construct factory in Interpreter, so that I can be sure that I'm setting the required attributes every time! :generalize_me

Replace Emerald_Error system. I don't like that I'm not having to rescue from my own exceptions, and I have to make sure that the proper error is bubbled up. It's already annoying and the Interpreter isn't even complicated.
Maybe Interpreter#report_error, similar to Jai's interp->report_error.

Importing other code by retrieving them from whatever scope they're in. For example, rng = .../Random.new, Local_Math = .../Math, etc. Or from a file with Local_Math = ~/math.e. I think this should create a File_Scope, which interprets the file upon assignment. That should open up the possibility of:
	maths = ~/math.e
	maths.sin, maths.cos, etc
Or:
	@ += ~/math.e
	sin, cos, etc
	@ -= ~/math.e   (or maybe @--, or something like that, to avoid having to type long paths)
Or:
	maths = ~/math.e
	@ += maths
	@ -= maths

Scope could extend Hash instead of having a @hash attribute, that would be less work for me, I think.
7/10/25, I tried this and it didn't go smoothly. I'll save this idea for another day!

Shorthand literals, but maybe they should be two-letter shorthands like in Ruby. Here are ideas for one-letter shorthands:
	#(abc 123) -> Hash {abc: nil, 123: nil} and if abc is defined locally, it should take its value too.
	%(this is a set)
	?(abc def) returns true if all truthy
	$(one two) strings like %w() in Ruby
	:(one two) symbols like %i() in Ruby
	^()
	etc...

Some way to keep track of instance IDs as an integer. These would be strictly for constructs(.rb), not expressions(.rb).
	@instance_count_by_class = {
		 Nil:                  0,
		 Instance:             0,
		 Type:                 0,
		 Func:                 0,
		 Scope:                0,
		 Tuple:                0,
		 Left_Exclusing_Range: 0,
		 # The rest can be added at runtime
	}

Take inspiration from Ruby unary operators for prefixes. `def -@`

Maybe bring back := as a declaration operator. I don't want to be forced to use it, but maybe it can be repurposed?

Initialize value-less declarations based on their type rather than just Nil.new. :make_use_of_type

You can use any Type identifier when declaring a type and it won't crash, even when the identifier is made up. That might seem like a bug, and it is. But what if it only crashes when you actually assign? `some: Thing` will just set {some: nil} in the scope. So it could remain a placeholder until assignment.

Add namespaces to each error to make it easier to identify, like Interpreter::Whatever_Error. Interpreter requires this file and done.
